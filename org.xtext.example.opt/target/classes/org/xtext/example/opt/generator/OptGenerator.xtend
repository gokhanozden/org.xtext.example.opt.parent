/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.opt.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.opt.opt.EvolutionaryStrategies
import org.xtext.example.opt.opt.Optimizer
import org.xtext.example.opt.opt.Objective
import org.xtext.example.opt.opt.Variable
import org.xtext.example.opt.opt.VariableType
import org.xtext.example.opt.opt.MaxIteration
import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*
import java.util.List;
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class OptGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('ES.java', ES(resource.allContents
				.filter(typeof(EvolutionaryStrategies)).head, resource.allContents
				.filter(typeof(Optimizer)).head, resource.allContents
				.filter(typeof(MaxIteration)).head, resource.allContents.toIterable
				.filter(typeof(Variable))))
		fsa.generateFile('solution.java', solution(resource.allContents
				.filter(typeof(EvolutionaryStrategies)).head, resource.allContents
				.filter(typeof(Optimizer)).head, resource.allContents.toIterable
				.filter(typeof(Variable))))
		fsa.generateFile('Main.java', Main())
	}
	
	def ES(EvolutionaryStrategies es, Optimizer op, MaxIteration maxit, Iterable<Variable> myvars)
	'''
		import java.util.Arrays;
		import java.util.Random;
		
		public class ES 
		{
			private solution[] parents;
			private int mu = «es.mu»;
			private int lambda = «es.lambda»;
			private double sigma = «es.sigma»;
			private int maxIteration = «maxit.maxiteration»;
			private int success;
			private int totaliteration;
			private int counter;
			private Random rand;
			private int seed = «op.seed»;
			
			public ES()
			{
				rand = new Random(seed);
			}
			
			public void createInitialPopulation()
			{
				parents = new solution[mu];
				for(int i = 0; i < mu; i++)
				{
					solution tmp = new solution();
					//Randomly create all the parameters between their lower and upper limits
					«val List<Variable> mylist = newArrayList()»
					«FOR variable : myvars»
					«//if (variable.type == VariableType.INTEGER) "uniformrandomint(tmp." + variable.name +"_lb" + ", tmp." + variable.name + "_ub);"»
					"tmp." + variable.name + " = uniformrandom(tmp." + variable.name +"_lb" + ", tmp." + variable.name + "_ub);"
					»
					«{mylist.add(variable); null}»
					«ENDFOR»
					parents[i] = tmp;
				}
			}
			
			public void Solve()
			{
				int counter1 = 0;
				for(int i = 0; i < maxIteration; i++)
				{
					if(counter1 == counter)
					{
						if((double)success / (double)totaliteration > 0.2)
						{
							sigma = sigma / 0.85;
						}
						else
						{
							sigma = sigma * 0.85;
						}
						counter1 = 0;
						success = 0;
						totaliteration = 0;
					}
					counter1++;
					evolution();
				}
			}
			
			private void evolution()
			{
				int[] parent = new int[lambda];
				int allpopulationsize = lambda + mu;//lambda + M strategy
				solution[] tmppopulation = new solution[allpopulationsize];
				
				//Copy parents to the tmppopulation
				for (int i = 0; i < mu; i++)
				{
					tmppopulation[i] = parents[i];
				}
				
				for (int i = 0; i < lambda; i++)
				{
					int index = i + mu;
					solution child = new solution();
					parent[i] = (int)Math.round(i * mu / lambda);
					«FOR variable : mylist»
					«if (variable.type == VariableType.INTEGER) "child." + variable.name +" = parents[parent[i]]." + variable.name +  " + normalDistInt(0, sigma);"»
					«if (variable.type == VariableType.DECIMAL) "child." + variable.name +" = parents[parent[i]]." + variable.name +  " + normalDistDouble(0, sigma);"»
					«ENDFOR»
					
					tmppopulation[index] = child;
					if (child.getCost() < parents[parent[i]].getCost())
					{
						success++;
					}
					totaliteration++;
				}
				tmppopulation = sortPopulation(tmppopulation);
				
				for (int i = 0; i < mu; i++)
				{
					parents[i] = tmppopulation[i];
				}
			}
			
			private solution[] sortPopulation(solution[] notSortedPopulation)
			{
				Arrays.sort(notSortedPopulation);
				return notSortedPopulation;
			}
			
			public double getCost()
			{
				//return cost of best solution in population
				return parents[0].getCost();
			}
			
			//Uniformly distributed integer random number generator with parameter mean and sigma
			private int uniformrandom(int minval, int maxval)
			{
				int randomNum = minval + rand.nextInt(maxval - minval);
				return randomNum;
			}
			//Uniformly distributed float random number generator with parameter mean and sigma
			private float uniformrandom(float minval, float maxval)
			{
				float randomNum = minval + (maxval - minval) * rand.nextFloat();
				return randomNum;
			}
			//Uniformly distributed double random number generator with parameter mean and sigma
			private double uniformrandom(double minval, double maxval)
			{
				double randomNum = minval + (maxval - minval) * rand.nextDouble();
				return randomNum;
			}
			
			private int normalDistInt(double mean, double sigma)
				{
					int size = 12;
					int precision = 1000000;
					double Z = 0;
					int Q = 0;
					double[] U = new double[size];
					for(int i = 0; i < size; i++)
					{
						U[i] = (double)rand.nextInt(precision) / precision;
					}
					for(int i = 0; i < size; i++)
					{
						Z = Z + U[i];
					}
					Z = Z - size / 2;
					Q = (int)(mean + sigma * Z);
					return Q;
				}
				
				private float normalDistFloat(double mean, double sigma)
				{
					int size = 12;
					int precision = 1000000;
					double Z = 0;
					float Q = 0;
					double[] U = new double[size];
					for(int i = 0; i < size; i++)
					{
						U[i] = (double)rand.nextInt(precision) / precision;
					}
					for(int i = 0; i < size; i++)
					{
						Z = Z + U[i];
					}
					Z = Z - size / 2;
					Q = (float)(mean + sigma * Z);
					return Q;
				}
				
				private double normalDistDouble(double mean, double sigma)
				{
					int size = 12;
					int precision = 1000000;
					double Z = 0;
					double Q = 0;
					double[] U = new double[size];
					for(int i = 0; i < size; i++)
					{
						U[i] = (double)rand.nextInt(precision) / precision;
					}
					for(int i = 0; i < size; i++)
					{
						Z = Z + U[i];
					}
					Z = Z - size / 2;
					Q = (double)(mean + sigma * Z);
					return Q;
				}
		}
	'''
	
	def solution(EvolutionaryStrategies es, Optimizer op, Iterable<Variable> myvars)
	'''
		public class solution implements Comparable<solution>
		{
			«FOR variable : myvars»
			public «variable.PrintType» «variable.name»;
			public «variable.PrintType» «variable.name»_lb = «variable.lowValue»;
			public «variable.PrintType» «variable.name»_ub = «variable.highValue»;
			«ENDFOR»
			private double cost = Double.MAX_VALUE;
			
			public solution()
			{
				
			}
			
			public double getCost()
			{
				if (cost == Double.MAX_VALUE)
				{
					cost = «op.objective.eContents.map['''«getNode.getTokenText»'''].join("\n")»;
					return cost;
				}
				else
				{
					return cost;
				}
			}
			
			public int compareTo(solution sol)
			{
				return Double.valueOf(this.getCost()).compareTo(Double.valueOf(sol.getCost()));
			}
		}
	'''
		
	def Main()
	'''	
		public class Main
		{	
			public static void main(String[] args)
			{
				ES myES = new ES();
				myES.createInitialPopulation();
				myES.Solve();
				System.out.println(myES.getCost());
			}
		}
	'''
	
	def PrintType(Variable myvar)
	{
		if (myvar.type == VariableType.BOOLEAN) "boolean"
		else if (myvar.type == VariableType.INTEGER) "int"
		else if (myvar.type == VariableType.STRING) "String"
		else if (myvar.type == VariableType.DECIMAL) "double"
		else myvar.type
	}
	
	def Sim(Objective myob)
	{
		
	}
}
